// Generated automatically from src/module/io.wren. Do not edit.
static const char* ioModuleSource =
"import \"scheduler\" for Scheduler\n"
"\n"
"class Directory {\n"
"  // TODO: Copied from File. Figure out good way to share this.\n"
"  static ensurePath_(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"  }\n"
"\n"
"  static list(path) {\n"
"    ensurePath_(path)\n"
"    list_(path, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  foreign static list_(path, fiber)\n"
"}\n"
"\n"
"foreign class File {\n"
"  static create(path) {\n"
"    return openWithFlags(path,\n"
"        FileFlags.writeOnly |\n"
"        FileFlags.create |\n"
"        FileFlags.truncate)\n"
"  }\n"
"\n"
"  static create(path, fn) {\n"
"    return openWithFlags(path,\n"
"        FileFlags.writeOnly |\n"
"        FileFlags.create |\n"
"        FileFlags.truncate, fn)\n"
"  }\n"
"\n"
"  static delete(path) {\n"
"    File.ensurePath_(path)\n"
"    delete_(path, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  static open(path) { openWithFlags(path, FileFlags.readOnly) }\n"
"\n"
"  static open(path, fn) { openWithFlags(path, FileFlags.readOnly, fn) }\n"
"\n"
"  // TODO: Add named parameters and then call this \"open(_,flags:_)\"?\n"
"  // TODO: Test.\n"
"  static openWithFlags(path, flags) {\n"
"    File.ensurePath_(path)\n"
"    File.ensureInt_(flags, \"Flags\")\n"
"    open_(path, flags, Fiber.current)\n"
"    var fd = Scheduler.runNextScheduled_()\n"
"    return new_(fd)\n"
"  }\n"
"\n"
"  static openWithFlags(path, flags, fn) {\n"
"    var file = openWithFlags(path, flags)\n"
"    var fiber = Fiber.new { fn.call(file) }\n"
"\n"
"    // Poor man's finally. Can we make this more elegant?\n"
"    var result = fiber.try()\n"
"    file.close()\n"
"\n"
"    // TODO: Want something like rethrow since now the callstack ends here. :(\n"
"    if (fiber.error != null) Fiber.abort(fiber.error)\n"
"    return result\n"
"  }\n"
"\n"
"  static read(path) {\n"
"    return File.open(path) {|file| file.readBytes(file.size) }\n"
"  }\n"
"\n"
"  static size(path) {\n"
"    File.ensurePath_(path)\n"
"    sizePath_(path, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  construct new_(fd) {}\n"
"\n"
"  close() {\n"
"    if (close_(Fiber.current)) return\n"
"    Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  foreign descriptor\n"
"\n"
"  isOpen { descriptor != -1 }\n"
"\n"
"  size {\n"
"    ensureOpen_()\n"
"    size_(Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  stat {\n"
"    ensureOpen_()\n"
"    stat_(Fiber.current)\n"
"    return Stat.new_(Scheduler.runNextScheduled_())\n"
"  }\n"
"\n"
"  readBytes(count) { readBytes(count, 0) }\n"
"\n"
"  readBytes(count, offset) {\n"
"    ensureOpen_()\n"
"    File.ensureInt_(count, \"Count\")\n"
"    File.ensureInt_(offset, \"Offset\")\n"
"\n"
"    readBytes_(count, offset, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  writeBytes(bytes) { writeBytes(bytes, size) }\n"
"\n"
"  writeBytes(bytes, offset) {\n"
"    ensureOpen_()\n"
"    if (!(bytes is String)) Fiber.abort(\"Bytes must be a string.\")\n"
"    File.ensureInt_(offset, \"Offset\")\n"
"\n"
"    writeBytes_(bytes, offset, Fiber.current)\n"
"    return Scheduler.runNextScheduled_()\n"
"  }\n"
"\n"
"  ensureOpen_() {\n"
"    if (!isOpen) Fiber.abort(\"File is not open.\")\n"
"  }\n"
"\n"
"  static ensurePath_(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"  }\n"
"\n"
"  static ensureInt_(value, name) {\n"
"    if (!(value is Num)) Fiber.abort(\"%(name) must be an integer.\")\n"
"    if (!value.isInteger) Fiber.abort(\"%(name) must be an integer.\")\n"
"    if (value < 0) Fiber.abort(\"%(name) cannot be negative.\")\n"
"  }\n"
"\n"
"  foreign static delete_(path, fiber)\n"
"  foreign static open_(path, flags, fiber)\n"
"  foreign static sizePath_(path, fiber)\n"
"\n"
"  foreign close_(fiber)\n"
"  foreign readBytes_(count, offset, fiber)\n"
"  foreign size_(fiber)\n"
"  foreign stat_(fiber)\n"
"  foreign writeBytes_(bytes, offset, fiber)\n"
"}\n"
"\n"
"class FileFlags {\n"
"  // Note: These must be kept in sync with mapFileFlags() in io.c.\n"
"\n"
"  static readOnly  { 0x01 }\n"
"  static writeOnly { 0x02 }\n"
"  static readWrite { 0x04 }\n"
"  static sync      { 0x08 }\n"
"  static create    { 0x10 }\n"
"  static truncate  { 0x20 }\n"
"  static exclusive { 0x40 }\n"
"}\n"
"\n"
"class Stat {\n"
"  construct new_(fields) {\n"
"    _fields = fields\n"
"  }\n"
"\n"
"  static path(path) {\n"
"    if (!(path is String)) Fiber.abort(\"Path must be a string.\")\n"
"\n"
"    path_(path, Fiber.current)\n"
"    return Stat.new_(Scheduler.runNextScheduled_())\n"
"  }\n"
"\n"
"  device { _fields[0] }\n"
"  inode { _fields[1] }\n"
"  mode { _fields[2] }\n"
"  linkCount { _fields[3] }\n"
"  user { _fields[4] }\n"
"  group { _fields[5] }\n"
"  specialDevice { _fields[6] }\n"
"  size { _fields[7] }\n"
"  blockSize { _fields[8] }\n"
"  blockCount { _fields[9] }\n"
"\n"
"  foreign static path_(path, fiber)\n"
"}\n"
"\n"
"class Stdin {\n"
"  static readLine() {\n"
"    if (__isClosed == true) {\n"
"      Fiber.abort(\"Stdin was closed.\")\n"
"    }\n"
"\n"
"    // TODO: Error if other fiber is already waiting.\n"
"    readStart_()\n"
"\n"
"    __waitingFiber = Fiber.current\n"
"    var line = Scheduler.runNextScheduled_()\n"
"\n"
"    readStop_()\n"
"    return line\n"
"  }\n"
"\n"
"  static onData_(data) {\n"
"    if (data == null) {\n"
"      __isClosed = true\n"
"      readStop_()\n"
"\n"
"      if (__line != null) {\n"
"        // Emit the last line.\n"
"        var line = __line\n"
"        __line = null\n"
"        if (__waitingFiber != null) __waitingFiber.transfer(line)\n"
"      } else {\n"
"        __waitingFiber.transferError(\"Stdin was closed.\")\n"
"      }\n"
"    }\n"
"\n"
"    // TODO: Handle Windows line separators.\n"
"    var lineSeparator = data.indexOf(\"\n\")\n"
"\n"
"    if (__line == null) __line = \"\"\n"
"    if (lineSeparator == -1) {\n"
"      // No end of line yet, so just accumulate it.\n"
"      __line = __line + data\n"
"    } else {\n"
"      // Split the line at the separator.\n"
"      var line = __line + data[0...lineSeparator]\n"
"      if (lineSeparator > 0 && lineSeparator < data.count - 1) {\n"
"        // Buffer up the characters after the separator for the next line.\n"
"        __line = data[lineSeparator + 1..-1]\n"
"      } else {\n"
"        __line = \"\"\n"
"      }\n"
"\n"
"      if (__waitingFiber != null) __waitingFiber.transfer(line)\n"
"    }\n"
"  }\n"
"\n"
"  foreign static readStart_()\n"
"  foreign static readStop_()\n"
"}\n";
